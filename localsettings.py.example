#!/usr/bin/env python
# -*- coding: UTF-8 -*-
import datetime
import os.path

DOMAIN_URL = "http://example.com"
APP_ROOT = "/webapps/cf_transcription"
PYLIBS_DIR = APP_ROOT + "/libs/python"

EXPORT_DIR = APP_ROOT + "/data/export"
CONVERSATION_DIR = APP_ROOT + "/data/conversations"
LISTS_DIR = APP_ROOT + "/data/lists"
SESSION_FNAME = 'session-fixed.xml'
SESSION_FNAMES = ('session-fixed.xml', 'session.xml')
# alternatives, tried from the first (up to the last if the previous did not
# exist)

USE_CF = True    # use Crowdflower?
WORKLOGS_DIR = APP_ROOT + "/log/work_logs"
CURLLOGS_DIR = APP_ROOT + "/log/curl_logs"
LOG_CURL = False

CODE_LENGTH = 6  # length of the validation code
CODE_LENGTH_EXT = 3  # length of the validation code extension

CF_KEY = "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd"

# Crowdflower job IDs
# -------------------
# There are three ways to specify Crowdflower job IDs for your dialogues.
#   1. CF_JOB_ID: this should be the ID of your single Crowdflower job if you
#       want to pay the same money for every transcription.
#   2. CF_JOB_IDS: this should be a mapping {job_price: job_ID} determining the
#       job ID for jobs with a price greater than or equal to job_price.  If
#       a job with a lower price than the lowest price step is uploaded to CF,
#       it will be uploaded with the lowest price available.
#   3. CF_JOBS_FNAME: path towards a file specifying the CF_JOB_IDS mapping,
#       one item per line, tab-separated.  This file is automatically created
#       and populated when creating Crowdflower jobs using the Create Jobs
#       view.
#
# Should more of these configuration variables be set, only one of them is
# used, the preference being 3. > 2. > 1.

# CF_JOB_ID = "123456"
CF_JOB_IDS = {0.05: '123457',
              0.10: '123458',
              0.15: '123459',
              0.20: '123460',
              0.25: '123461',
              0.30: '123462',
              0.35: '123463',
              0.40: '123464'}
CF_JOBS_FNAME = os.path.join(APP_ROOT, 'transcription', 'crowdflower',
                             'jobs.lst')
# CF_WAIT_SECS: How long to give Crowdflower before asking it about newly
# uploaded jobs.
CF_WAIT_SECS = 1

PRICE_CONST = 2 * 0.01
PRICE_PER_MIN = 30 * 0.01
PRICE_PER_TURN = 0.5 * 0.01
MIN_TURNS = 2

MAX_ANNOTATIONS_PER_INPUT = 1
SESSION_EXPIRED = datetime.timedelta(hours=12)

# maximum tolerated character error rate in transcriptions (after
# normalisation)
#
# The value 0.07 implies that one in 14--15 characters being wrong shall be
# tolerated.
MAX_CHAR_ER = 0.07

# What all information about a finalized job should be stored in the XML
# session file?
#
# Format: [ (Crowdflower JSON key, target XML attribute) ]
LOGGED_JOB_DATA = [
#     ("webhook_sent_at", "webhook_sent_at"),
#     ("city", "city"),
#     ("region", "region"),
#     ("created_at", "created_at"),
#     ("unit_id", "unit_id"),
#     ("unit_state", "unit_state"),
    ("country", "country"),
    ("worker_trust", "worker_trust"),
#     ("judgment", "judgment"),
#     ("tainted", "tainted"),
#     ("trust", "trust"),
#     ("id", "cf_id"),
    ("external_type", "channel"),
#     ("reviewed", "reviewed"),
#     ("worker_id", "worker_id"),  # This is always logged.
#     ("missed", "missed"),
#     ("started_at", "started_at"),
#     ("golden", "golden"),
#     ("job_id", "job_id"),
#     ("rejected", "rejected"),
]

XML_COMMON = {
    'ANNOTATIONS_ABOVE': ".",
    'ANNOTATIONS_AFTER': "turn",  # This has to point to a direct child of
                                  # ANNOTATIONS_ABOVE.
    'ANNOTATIONS_ELEM': "annotations",
    'ANNOTATION_ELEM': "annotation",
    'REC_SUBPATH': "rec",
    'REC_FNAME_ATTR': "fname"
}

XML_SCHEMES = {
    'dialog': {
        'USERTURN_PATH': ".//userturn",
        'SYSTURN_PATH': ".//systurn",
        'TURNNUMBER_ATTR': "turnnum",
        'SYSTEXT_SUBPATH': "prompt",
        'TRANSCRIPTIONS_BEFORE': "asr",
        'TRANSCRIPTIONS_ELEM': "transcriptions",
        'TRANSCRIPTION_BEFORE': None,
        'TRANSCRIPTION_ELEM': "transcription",
        'AUTHOR_ATTR': "author",
        'DATE_ATTR': "date_updated",
        'DATE_FORMAT': None
    },
    'dialogue': {
        'USERTURN_PATH': ".//turn[@speaker='user']",
        'SYSTURN_PATH': ".//turn[@speaker='system']",
        'TURNNUMBER_ATTR': "turn_number",
        'SYSTEXT_SUBPATH': "text",
        'TRANSCRIPTIONS_BEFORE': None,
        'TRANSCRIPTIONS_ELEM': None,
        'TRANSCRIPTION_BEFORE': "slu",
        'TRANSCRIPTION_ELEM': "asr_transcription",
        'AUTHOR_ATTR': "transcriber",
        'DATE_ATTR': "date",
# NOTE: including timezone info into the datetime format could disable
# finding the transcription in its XML if the timezone setting changes
        'DATE_FORMAT': "%d/%m/%y, %H:%M:%S %Z"
    }
}

TRANSCRIBE_EXTRA_CONTEXT = {
    'instruction_includes': ('trs/numerals.html',
                             'trs/ortography.html',
                             'trs/incomplete_words.html',
                             'trs/nonspeech_sounds.html',
                             # 'trs/censoring.html',
                             'trs/localnames-cir.html',
                             'trs/donotspam.html',
                             )
}
